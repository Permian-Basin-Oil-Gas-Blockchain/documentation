= IMA Token Access Control
:icons: font
:toc: macro

ifdef::env-github[]

:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:

endif::[]

toc::[]

== Introduction

The SKALE Chain owner has special permissions to setup specific IMA parameters, such as IMA access control. These permissions include:

* Enable/disable whitelist on mainnet (default: enabled)
* Enable/disable automatic deployment on schain (default: disabled)
* AddERC20TokenByOwner on mainnet and on schain
* AddERC721TokenByOwner on mainnet and on schain

== Enable or Disable the Whitelist

The token whitelist allows the Schain owner to allow token exchange through IMA and a SKALE chain. For example, a decentralized exchange may prefer to disable the whitelist to allow any token transfer. A dApp using only one token may enable the whitelist to allow only a single token exchange. 

To disable the whitelist, the owner executes `disableWhitelist` in LockAndDataForMainnetERC20 or LockAndDataForMainnetERC721 contracts, and pass in the schainName as the only argument. For example:

```python
lock_and_data_for_mainnet_erc20 = self._get_contract_on_mainnet('lock_and_data_for_mainnet_erc20')
disable = lock_and_data_for_mainnet_erc20.encodeABI(fn_name="disableWhitelist", args=[schainName])

signed_txn = self.web3_mainnet.eth.account.signTransaction(dict(
        nonce=self.web3_mainnet.eth.getTransactionCount(sender_address),
        gasPrice=self.web3_mainnet.eth.gasPrice,
        gas=200000,
        to=lock_and_data_for_mainnet_erc20.address,
        value=0,
        data = disable
    ),
    from_key)

self.web3_mainnet.eth.sendRawTransaction(signed_txn.rawTransaction)
```

To re-enable the whitelist, the owner executes `enableWhitelist` as demonstrated above.

== Adding tokens with Enabled Whitelist

If the whitelist is enabled, the SKALE chain owner must authorize each token for the schain. 

You can use `addERC20TokenByOwner` and `addERC721TokenByOwner` functions available in LockAndData contracts on both Mainnet and each Schain.

The recommended process is

1. Deploy the ERC20 or ERC721 token contract on the SKALE chain.
2. Add the token to LockAndData on the Schain.
3. Grant the token's minter role to LockAndData on the Schain.
4. Add the token to LockAndData on Mainnet.

=== Adding tokens to LockAndData on Schain

NOTE: `addERC20TokenByOwner` on the LockAndDataForSchain takes 3 arguments. When enabling transfers to mainnet, `schainName` is set to "Mainnet". When enabling transfers to another schain, `schainName` is set to the other schain name.

An example for ERC20 (same procedure applies to ERC721):

```python
lock_and_data_for_schain_erc20 = self._get_contract_on_schain('lock_and_data_for_schain_erc20')
addERC20Schain = lock_and_data_for_schain_erc20.encodeABI(fn_name="addERC20TokenByOwner", args=[schainName, erc20MainnetAddress, erc20SchainAddress])

signed_txn = self.web3_schain.eth.account.signTransaction(dict(
        nonce=self.web3_schain.eth.getTransactionCount(sender_address),
        gasPrice=self.web3_schain.eth.gasPrice,
        gas=200000,
        to=lock_and_data_for_schain_erc20.address,
        value=0,
        data = addERC20Schain
    ),
    from_key)

self.web3_schain.eth.sendRawTransaction(signed_txn.rawTransaction)
```

=== Assign Schain LockAndData as Minter and Burner role

You need to assign LockAndData as the minter and burner for the deployed token on the schain. For AccessControl supported ERC20/ERC721, you can use apply the following pseudocode:

```
newERC20 = deployERC20(deployer)
minterRoleERC20 = newERC20.MINTER_ROLE()
newERC20.grantRole(minterRoleERC20, lockAndDataERC20.address);
```

=== Adding tokens to Mainnet LockAndData

NOTE: `addERC20TokenByOwner` on the LockAndDataForMainnet takes 2 arguments: schainName and erc20Mainnet address.

An example for ERC20 (same procedure applies to ERC721):

```python
lock_and_data_for_mainnet_erc20 = self._get_contract_on_mainnet('lock_and_data_for_mainnet_erc20')
addERC20Mainnet = lock_and_data_for_mainnet_erc20.encodeABI(fn_name="addERC20TokenByOwner", args=[schainName, erc20MainnetAddress])

signed_txn = self.web3_mainnet.eth.account.signTransaction(dict(
        nonce=self.web3_mainnet.eth.getTransactionCount(sender_address),
        gasPrice=self.web3_mainnet.eth.gasPrice,
        gas=200000,
        to=lock_and_data_for_mainnet_erc20.address,
        value=0,
        data = addERC20Mainnet
    ),
    from_key)

self.web3_mainnet.eth.sendRawTransaction(signed_txn.rawTransaction)
```

== Automatic deployment

Automatic deployment is disabled by default and requires that the Schain owner deploys the token contract on the schain. 

If enabled, then tokens are automatically deployed on the schain by the TokenFactory contract after a token is received through DepositBox on mainnet.

NOTE: Automatic deployment is currently not supported by skaled.
